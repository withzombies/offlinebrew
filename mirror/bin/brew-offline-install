#!/usr/bin/env ruby
# frozen_string_literal: true

# brew-offline-install: Install formulae or casks from an offline mirror (macOS only)
#
# Usage:
#   brew-offline-install <formula>           # Install a formula
#   brew-offline-install --cask <caskname>   # Install a cask
#   brew-offline-install <formula> <formula> # Install multiple formulae
#   brew-offline-install --cask <cask> <cask> # Install multiple casks
#
# Configuration:
#   ~/.offlinebrew/config.json must contain:
#     {"baseurl": "http://mirror-server:8000"}
#
# The mirror must be created with brew-mirror and served via HTTP.
#
# How it works on macOS:
#   This script uses cache pre-population to enable offline installation.
#   Before running 'brew install', all required files are downloaded from
#   the mirror and placed in Homebrew's cache directory with proper naming
#   (sha256--filename). When Homebrew runs, it finds these files in its
#   cache and uses them instead of downloading from the internet.

require "json"
require "net/http"
require_relative "../lib/safe_shell"
require_relative "../lib/homebrew_paths"
require_relative "../lib/offlinebrew_config"

# Validate configuration and environment
#
# @param config [Hash] Configuration hash with taps
# @param is_cask_install [Boolean] Whether this is a cask installation
def validate_configuration(config, is_cask_install)
  # Check if the mirror has the required tap
  taps = config[:taps] || config["taps"] || {}

  if is_cask_install
    unless taps["homebrew/homebrew-cask"]
      abort <<~ERROR
        ERROR: This mirror does not include casks.
        The mirror was created without the homebrew-cask tap.

        To create a mirror with cask support:
          brew ruby mirror/bin/brew-mirror -d /path/to/mirror --casks <cask-names>

        Or mirror all casks by omitting the --casks flag.
      ERROR
    end

    # Check if cask tap is installed locally
    unless HomebrewPaths.cask_tap_exists?
      abort <<~ERROR
        ERROR: homebrew-cask tap not installed locally.

        Please install it first:
          brew tap homebrew/cask

        Then try your installation again.
      ERROR
    end
  end

  # Verify all mirrored taps are installed locally
  taps.each do |tap_name, tap_info|
    tap_dir = case tap_name
              when "homebrew/homebrew-core"
                HomebrewPaths.core_tap_path
              when "homebrew/homebrew-cask"
                HomebrewPaths.cask_tap_path
              else
                user, repo = tap_name.split("/")
                HomebrewPaths.tap_path(user, repo)
              end

    # Skip directory check for bundled taps (Homebrew 5.0+)
    # Bundled taps don't exist as separate directories, which is expected
    tap_commit = tap_info["commit"] || tap_info[:commit]
    next if tap_commit&.start_with?("bundled-")

    unless Dir.exist?(tap_dir)
      warn "Warning: Tap #{tap_name} from mirror not found at #{tap_dir}"
      warn "         Installation may fail if packages depend on this tap"
    end
  end
end

# Dynamically detect homebrew-core tap location
CORE_TAP_DIR = HomebrewPaths.core_tap_path

# Verify Homebrew is installed before proceeding
unless HomebrewPaths.homebrew_installed?
  abort "Fatal: Homebrew is not installed or not in PATH"
end

# On exit, return all taps to their master branches.
# It shouldn't actually hurt us to stay at whatever prior revision
# we rewind to, but this should keep the number of warnings raised
# by Homebrew down.
at_exit do
  # Restore core tap (only if it's a git repository, not bundled)
  if Dir.exist?(CORE_TAP_DIR) && Dir.exist?(File.join(CORE_TAP_DIR, '.git'))
    Dir.chdir CORE_TAP_DIR do
      SafeShell.execute('git', 'checkout', 'master', timeout: 10, allowed_failures: true)
    end
  end

  # Restore cask tap if it exists and is a git repository
  cask_tap_dir = HomebrewPaths.cask_tap_path
  if Dir.exist?(cask_tap_dir) && Dir.exist?(File.join(cask_tap_dir, '.git'))
    Dir.chdir cask_tap_dir do
      SafeShell.execute('git', 'checkout', 'master', timeout: 10, allowed_failures: true)
    end
  end
end

# We're doing a lot of fiddling below, so we want Homebrew to be as loud
# as possible about everything it does.
ENV["HOMEBREW_VERBOSE"] = "1"

# Set REAL_HOME so that our shim scripts can find the config even when
# Homebrew runs them with a fake $HOME (which happens during sandbox builds).
# Only set if not already set (to allow tests to override).
ENV["REAL_HOME"] ||= Dir.home

# We want to minimize the number of non-package network requests we do,
# both for performance and stability reasons.
ENV["HOMEBREW_NO_ANALYTICS"] = "1"

# We also don't want Homebrew changing the versions of packages underneath
# us without having a chance to update the mirror first.
ENV["HOMEBREW_NO_AUTO_UPDATE"] = "1"

# Homebrew will try to use GitHub's REST API to minimize (presumably expensive)
# `git` backend operations. But we don't support GitHub's rest API, so we
# need to tell Homebrew not to treat GitHub git repositories specially.
ENV["HOMEBREW_NO_GITHUB_API"] = "1"

# HOMEBREW_BUILD_FROM_SOURCE tells Homebrew to completely ignore bottles.
# We do this because the mirror currently only contains source packages.
ENV["HOMEBREW_BUILD_FROM_SOURCE"] = "1"

# Cache Pre-Population for macOS
#
# macOS Homebrew doesn't support HOMEBREW_CURL_PATH for intercepting downloads.
# Instead, we pre-populate Homebrew's cache directory with files from the mirror
# before running 'brew install'. This is the most reliable offline approach.
#
# How it works:
#   1. Fetch all files from the mirror's urlmap
#   2. Calculate SHA256 hash of each file
#   3. Write to cache as: downloads/sha256--filename
#   4. When Homebrew runs, it finds files in cache and skips downloading

require 'net/http'
require 'fileutils'
require 'digest'

def prepopulate_cache_from_mirror(formulae, urlmap, baseurl, cache_dir)
  downloads_dir = File.join(cache_dir, "downloads")
  FileUtils.mkdir_p(downloads_dir)

  populated = 0
  failed = []

  urlmap.each do |url, mirror_file|
    mirror_url = URI.join(baseurl, mirror_file)

    begin
      response = Net::HTTP.get_response(URI(mirror_url))

      if response.is_a?(Net::HTTPSuccess)
        # Homebrew cache files use format: sha256--filename
        content = response.body
        sha256 = Digest::SHA256.hexdigest(content)
        filename = File.basename(URI(url).path)
        cache_filename = "#{sha256}--#{filename}"
        cache_path = File.join(downloads_dir, cache_filename)

        File.binwrite(cache_path, content)
        populated += 1
      else
        failed << mirror_file
      end
    rescue => e
      failed << mirror_file
    end
  end

  puts "Pre-populated #{populated} files from mirror into Homebrew cache" if populated > 0

  if failed.any?
    warn "Warning: Failed to fetch #{failed.length} files from mirror"
    warn "Mirror server may be unreachable. Check: #{baseurl}"
    warn "Installation may fall back to internet downloads for missing files"
  end
end

# Detect if user is trying to install a cask
is_cask_install = ARGV.include?("--cask") || ARGV.include?("cask")
is_cask_install = true if ARGV.first == "cask"

# Use OfflinebrewConfig for consistent config location detection
# NOTE: These are runtime variables, not constants, so they're evaluated
# when the script runs (allowing REAL_HOME environment variable to work)

brew_offline_dir = OfflinebrewConfig.config_dir

# TODO(ww): We should be fetching most of the configuration options from
# the mirror, and not storing them locally. The only thing we really
# want (and need) locally is the mirror's address.
brew_offline_local_config = OfflinebrewConfig.config_path
brew_offline_local_urlmap = OfflinebrewConfig.urlmap_path

config = JSON.parse File.read(brew_offline_local_config), symbolize_names: true
baseurl = config[:baseurl]

abort "Missing configuration key: baseurl" unless baseurl

BREW_OFFLINE_REMOTE_CONFIG = URI.join baseurl, "config.json"
BREW_OFFLINE_REMOTE_URLMAP = URI.join baseurl, "urlmap.json"

# Clobber our config, and write the remote config/urlmap to disk
# locally for the `curl` and `git` shims to read.
begin
  config_json = Net::HTTP.get(BREW_OFFLINE_REMOTE_CONFIG)
  urlmap = JSON.parse Net::HTTP.get(BREW_OFFLINE_REMOTE_URLMAP)

  config = JSON.parse config_json
  config = config.transform_keys(&:to_sym) if config.is_a?(Hash)

  # The remote config doesn't get to clobber our baseurl.
  config[:baseurl] = baseurl
rescue StandardError => e
  abort "#{e}: #{e.message} while fetching remote configuration and urlmap!"
end

# Require new tap-based config format (Homebrew 5.0+ only)
if config[:commit]
  abort <<~ERROR
    ❌ Legacy config format detected!

    Your config uses the old single-tap format:
    {
      "commit": "#{config[:commit][0..10]}...",
      "formulae": [...]
    }

    This format is no longer supported. Please use the new multi-tap format:
    {
      "taps": {
        "homebrew/homebrew-core": {
          "commit": "bundled-5.0",
          "type": "formula"
        }
      },
      "formulae": [...],
      "casks": [...]
    }

    For bundled taps in Homebrew 5.0+, use "bundled-5.0" as the commit.
  ERROR
end

unless config[:taps]
  abort <<~ERROR
    ❌ Invalid config format: 'taps' section is required

    Config must include a 'taps' section:
    {
      "taps": {
        "homebrew/homebrew-core": {
          "commit": "bundled-5.0",
          "type": "formula"
        }
      },
      "formulae": ["wget", "curl"]
    }
  ERROR
end

taps = config[:taps]

# Validate each tap configuration
taps.each do |tap_name, tap_config|
  unless tap_config.is_a?(Hash)
    abort "❌ Invalid tap config for #{tap_name}: must be a hash with 'commit' and 'type'"
  end

  unless tap_config["commit"] || tap_config[:commit]
    abort "❌ Invalid tap config for #{tap_name}: missing 'commit' field"
  end

  unless tap_config["type"] || tap_config[:type]
    abort "❌ Invalid tap config for #{tap_name}: missing 'type' field (formula/cask/mixed)"
  end
end

# Validate configuration
validate_configuration(config.merge(taps: taps), is_cask_install)

File.write brew_offline_local_config, config.to_json
File.write brew_offline_local_urlmap, urlmap.to_json

# Pre-populate Homebrew cache from mirror (most reliable method for macOS)
homebrew_cache = `brew --cache`.chomp
prepopulate_cache_from_mirror(ARGV, urlmap, baseurl, homebrew_cache)

# Each of these flags would cause us to attempt to retrieve
# an asset that we don't mirror, so we catch them early on
# and warn the user about them explicitly.
INVALID_FORMULA_FLAGS = %w[
  --force-bottle
  --devel
  --HEAD
].freeze

INVALID_CASK_FLAGS = %w[
  --no-quarantine
  --language
  --greedy
].freeze

if is_cask_install
  invalid_flags = ARGV & INVALID_CASK_FLAGS
  if invalid_flags.any?
    abort "Cask installation with these flags not supported: #{invalid_flags.join(", ")}"
  end
else
  invalid_flags = ARGV & INVALID_FORMULA_FLAGS
  if invalid_flags.any?
    abort "One or more invalid flags passed: #{invalid_flags.join(", ")}"
  end

  # This shouldn't be necessary thanks to HOMEBREW_BUILD_FROM_SOURCE, but putting
  # in the ARGV may help us trace where things go wrong.
  ARGV << "--build-from-source"
end

# Nuke Homebrew's cache. We don't want to assume that our mirroring server
# supports resumeable downloads or `git fetch`.
system "brew", "cleanup", "-s", "--prune=0"

# Reset all mirrored taps to their respective commits
# This ensures we install the exact versions we mirrored
puts "Resetting taps to mirrored commits..."
taps.each do |tap_name, tap_info|
  tap_commit = tap_info["commit"] || tap_info[:commit]
  tap_type = tap_info["type"] || tap_info[:type] || "unknown"

  # Determine tap directory
  tap_dir = case tap_name
            when "homebrew/homebrew-core"
              HomebrewPaths.core_tap_path
            when "homebrew/homebrew-cask"
              HomebrewPaths.cask_tap_path
            else
              # Generic tap path
              user, repo = tap_name.split("/")
              HomebrewPaths.tap_path(user, repo)
            end

  # Skip git operations for bundled taps (Homebrew 5.0+)
  if tap_commit.start_with?("bundled-")
    puts "  #{tap_name} is bundled at #{tap_commit} (no checkout needed)"
    next
  end

  unless Dir.exist?(tap_dir)
    warn "Warning: Tap not found: #{tap_name} at #{tap_dir}, skipping"
    next
  end

  # Verify this is a git repository before attempting git operations
  unless Dir.exist?(File.join(tap_dir, '.git'))
    warn "Warning: #{tap_name} is not a git repository, skipping checkout"
    next
  end

  puts "  Resetting #{tap_name} to #{tap_commit[0..7]}..."
  Dir.chdir tap_dir do
    # Try to fetch the commit (may not be in local repo)
    system "git", "fetch", "--quiet", "origin"

    # Checkout the specific commit
    result = system "git", "checkout", "--quiet", tap_commit

    unless result
      warn "  Warning: Failed to checkout #{tap_name} at #{tap_commit}"
      warn "  This may cause installation to fail"
    end
  end
end

puts ""

# Run the appropriate install command
if is_cask_install
  # For cask installs
  # Remove 'cask' from ARGV if it's the first argument
  args = ARGV.dup
  args.shift if args.first == "cask"

  puts "Installing cask(s): #{args.join(", ")}"
  success = system "brew", "install", "--cask", *args
else
  # For formula installs
  puts "Installing formula(e): #{ARGV.join(", ")}"
  success = system "brew", "install", *ARGV
end

# Check result
unless success
  abort "Installation failed! Check the output above for errors."
end

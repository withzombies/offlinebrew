#!/usr/bin/env ruby
# frozen_string_literal: true

# brew-offline-install: Install formulae or casks from an offline mirror
#
# Usage:
#   brew-offline-install <formula>           # Install a formula
#   brew-offline-install --cask <caskname>   # Install a cask
#   brew-offline-install <formula> <formula> # Install multiple formulae
#   brew-offline-install --cask <cask> <cask> # Install multiple casks
#
# Configuration:
#   ~/.offlinebrew/config.json must contain:
#     {"baseurl": "http://mirror-server:8000"}
#
# The mirror must be created with brew-mirror and served via HTTP.
# This script will reset taps to mirrored commits and use local shims
# to redirect all downloads to the local mirror.

require "json"
require "net/http"
require_relative "../lib/safe_shell"
require_relative "../lib/homebrew_paths"
require_relative "../lib/offlinebrew_config"

# Validate configuration and environment
#
# @param config [Hash] Configuration hash with taps
# @param is_cask_install [Boolean] Whether this is a cask installation
def validate_configuration(config, is_cask_install)
  # Check if the mirror has the required tap
  taps = config[:taps] || config["taps"] || {}

  if is_cask_install
    unless taps["homebrew/homebrew-cask"]
      abort <<~ERROR
        ERROR: This mirror does not include casks.
        The mirror was created without the homebrew-cask tap.

        To create a mirror with cask support:
          brew ruby mirror/bin/brew-mirror -d /path/to/mirror --casks <cask-names>

        Or mirror all casks by omitting the --casks flag.
      ERROR
    end

    # Check if cask tap is installed locally
    unless HomebrewPaths.cask_tap_exists?
      abort <<~ERROR
        ERROR: homebrew-cask tap not installed locally.

        Please install it first:
          brew tap homebrew/cask

        Then try your installation again.
      ERROR
    end
  end

  # Verify all mirrored taps are installed locally
  taps.each do |tap_name, _tap_info|
    tap_dir = case tap_name
              when "homebrew/homebrew-core"
                HomebrewPaths.core_tap_path
              when "homebrew/homebrew-cask"
                HomebrewPaths.cask_tap_path
              else
                user, repo = tap_name.split("/")
                HomebrewPaths.tap_path(user, repo)
              end

    unless Dir.exist?(tap_dir)
      warn "Warning: Tap #{tap_name} from mirror not found at #{tap_dir}"
      warn "         Installation may fail if packages depend on this tap"
    end
  end
end

# Dynamically detect homebrew-core tap location
CORE_TAP_DIR = HomebrewPaths.core_tap_path

# Verify Homebrew is installed before proceeding
unless HomebrewPaths.homebrew_installed?
  abort "Fatal: Homebrew is not installed or not in PATH"
end

# Verify homebrew-core tap exists
unless Dir.exist?(CORE_TAP_DIR)
  abort "Fatal: homebrew-core tap not found at #{CORE_TAP_DIR}"
end

# On exit, return all taps to their master branches.
# It shouldn't actually hurt us to stay at whatever prior revision
# we rewind to, but this should keep the number of warnings raised
# by Homebrew down.
at_exit do
  # Restore core tap
  Dir.chdir CORE_TAP_DIR do
    SafeShell.execute('git', 'checkout', 'master', timeout: 10, allowed_failures: true)
  end

  # Restore cask tap if it exists
  cask_tap_dir = HomebrewPaths.cask_tap_path
  if Dir.exist?(cask_tap_dir)
    Dir.chdir cask_tap_dir do
      SafeShell.execute('git', 'checkout', 'master', timeout: 10, allowed_failures: true)
    end
  end
end

# We're doing a lot of fiddling below, so we want Homebrew to be as loud
# as possible about everything it does.
ENV["HOMEBREW_VERBOSE"] = "1"

# Set REAL_HOME so that our shim scripts can find the config even when
# Homebrew runs them with a fake $HOME (which happens during sandbox builds).
# Only set if not already set (to allow tests to override).
ENV["REAL_HOME"] ||= Dir.home

# We want to minimize the number of non-package network requests we do,
# both for performance and stability reasons.
ENV["HOMEBREW_NO_ANALYTICS"] = "1"

# We also don't want Homebrew changing the versions of packages underneath
# us without having a chance to update the mirror first.
ENV["HOMEBREW_NO_AUTO_UPDATE"] = "1"

# Homebrew will try to use GitHub's REST API to minimize (presumably expensive)
# `git` backend operations. But we don't support GitHub's rest API, so we
# need to tell Homebrew not to treat GitHub git repositories specially.
ENV["HOMEBREW_NO_GITHUB_API"] = "1"

# HOMEBREW_BUILD_FROM_SOURCE tells Homebrew to completely ignore bottles.
# We do this because the mirror currently only contains source packages.
ENV["HOMEBREW_BUILD_FROM_SOURCE"] = "1"

# HOMEBREW_DEVELOPER tells Homebrew to run in developer mode.
# We do this so that Homebrew will respect HOMEBREW_CURL_PATH
# and HOMEBREW_GIT_PATH below.
ENV["HOMEBREW_DEVELOPER"] = "1"

# HOMEBREW_CURL_PATH and HOMEBREW_GIT_PATH tell Homebrew where to look for
# `curl` and `git` executables when running in developer mode.
# In this case, they point to our URL-rewriting shim scripts.
ENV["HOMEBREW_CURL_PATH"] = "brew-offline-curl"
ENV["HOMEBREW_GIT_PATH"] = "brew-offline-git"

# Detect if user is trying to install a cask
is_cask_install = ARGV.include?("--cask") || ARGV.include?("cask")
is_cask_install = true if ARGV.first == "cask"

# Use OfflinebrewConfig for consistent config location detection
# NOTE: These are runtime variables, not constants, so they're evaluated
# when the script runs (allowing REAL_HOME environment variable to work)

# DEBUG: Print environment info
warn "DEBUG brew-offline-install: ENV['REAL_HOME'] = #{ENV['REAL_HOME'].inspect}"
warn "DEBUG brew-offline-install: ENV['HOME'] = #{ENV['HOME'].inspect}"
warn "DEBUG brew-offline-install: OfflinebrewConfig.real_home_directory = #{OfflinebrewConfig.real_home_directory.inspect}"

brew_offline_dir = OfflinebrewConfig.config_dir

# TODO(ww): We should be fetching most of the configuration options from
# the mirror, and not storing them locally. The only thing we really
# want (and need) locally is the mirror's address.
brew_offline_local_config = OfflinebrewConfig.config_path
brew_offline_local_urlmap = OfflinebrewConfig.urlmap_path

warn "DEBUG brew-offline-install: brew_offline_local_config = #{brew_offline_local_config.inspect}"
warn "DEBUG brew-offline-install: Attempting to read config file..."

config = JSON.parse File.read(brew_offline_local_config), symbolize_names: true
baseurl = config[:baseurl]

abort "Missing configuration key: baseurl" unless baseurl

BREW_OFFLINE_REMOTE_CONFIG = URI.join baseurl, "config.json"
BREW_OFFLINE_REMOTE_URLMAP = URI.join baseurl, "urlmap.json"

# Clobber our config, and write the remote config/urlmap to disk
# locally for the `curl` and `git` shims to read.
begin
  config_json = Net::HTTP.get(BREW_OFFLINE_REMOTE_CONFIG)
  urlmap = JSON.parse Net::HTTP.get(BREW_OFFLINE_REMOTE_URLMAP)

  config = JSON.parse config_json
  config = config.transform_keys(&:to_sym) if config.is_a?(Hash)

  # The remote config doesn't get to clobber our baseurl.
  config[:baseurl] = baseurl
rescue StandardError => e
  abort "#{e}: #{e.message} while fetching remote configuration and urlmap!"
end

# Require new tap-based config format (Homebrew 5.0+ only)
if config[:commit]
  abort <<~ERROR
    ❌ Legacy config format detected!

    Your config uses the old single-tap format:
    {
      "commit": "#{config[:commit][0..10]}...",
      "formulae": [...]
    }

    This format is no longer supported. Please use the new multi-tap format:
    {
      "taps": {
        "homebrew/homebrew-core": {
          "commit": "bundled-5.0",
          "type": "formula"
        }
      },
      "formulae": [...],
      "casks": [...]
    }

    For bundled taps in Homebrew 5.0+, use "bundled-5.0" as the commit.
  ERROR
end

unless config[:taps]
  abort <<~ERROR
    ❌ Invalid config format: 'taps' section is required

    Config must include a 'taps' section:
    {
      "taps": {
        "homebrew/homebrew-core": {
          "commit": "bundled-5.0",
          "type": "formula"
        }
      },
      "formulae": ["wget", "curl"]
    }
  ERROR
end

taps = config[:taps]

# Validate each tap configuration
taps.each do |tap_name, tap_config|
  unless tap_config.is_a?(Hash)
    abort "❌ Invalid tap config for #{tap_name}: must be a hash with 'commit' and 'type'"
  end

  unless tap_config["commit"] || tap_config[:commit]
    abort "❌ Invalid tap config for #{tap_name}: missing 'commit' field"
  end

  unless tap_config["type"] || tap_config[:type]
    abort "❌ Invalid tap config for #{tap_name}: missing 'type' field (formula/cask/mixed)"
  end
end

# Validate configuration
validate_configuration(config.merge(taps: taps), is_cask_install)

File.write brew_offline_local_config, config.to_json
File.write brew_offline_local_urlmap, urlmap.to_json

# Each of these flags would cause us to attempt to retrieve
# an asset that we don't mirror, so we catch them early on
# and warn the user about them explicitly.
INVALID_FORMULA_FLAGS = %w[
  --force-bottle
  --devel
  --HEAD
].freeze

INVALID_CASK_FLAGS = %w[
  --no-quarantine
  --language
  --greedy
].freeze

if is_cask_install
  invalid_flags = ARGV & INVALID_CASK_FLAGS
  if invalid_flags.any?
    abort "Cask installation with these flags not supported: #{invalid_flags.join(", ")}"
  end
else
  invalid_flags = ARGV & INVALID_FORMULA_FLAGS
  if invalid_flags.any?
    abort "One or more invalid flags passed: #{invalid_flags.join(", ")}"
  end

  # This shouldn't be necessary thanks to HOMEBREW_BUILD_FROM_SOURCE, but putting
  # in the ARGV may help us trace where things go wrong.
  ARGV << "--build-from-source"
end

# Nuke Homebrew's cache. We don't want to assume that our mirroring server
# supports resumeable downloads or `git fetch`.
system "brew", "cleanup", "-s", "--prune=0"

# Reset all mirrored taps to their respective commits
# This ensures we install the exact versions we mirrored
puts "Resetting taps to mirrored commits..."
taps.each do |tap_name, tap_info|
  tap_commit = tap_info["commit"] || tap_info[:commit]
  tap_type = tap_info["type"] || tap_info[:type] || "unknown"

  # Determine tap directory
  tap_dir = case tap_name
            when "homebrew/homebrew-core"
              HomebrewPaths.core_tap_path
            when "homebrew/homebrew-cask"
              HomebrewPaths.cask_tap_path
            else
              # Generic tap path
              user, repo = tap_name.split("/")
              HomebrewPaths.tap_path(user, repo)
            end

  unless Dir.exist?(tap_dir)
    warn "Warning: Tap not found: #{tap_name} at #{tap_dir}, skipping"
    next
  end

  puts "  Resetting #{tap_name} to #{tap_commit[0..7]}..."
  Dir.chdir tap_dir do
    # Try to fetch the commit (may not be in local repo)
    system "git", "fetch", "--quiet", "origin"

    # Checkout the specific commit
    result = system "git", "checkout", "--quiet", tap_commit

    unless result
      warn "  Warning: Failed to checkout #{tap_name} at #{tap_commit}"
      warn "  This may cause installation to fail"
    end
  end
end

puts ""

# Run the appropriate install command
if is_cask_install
  # For cask installs
  # Remove 'cask' from ARGV if it's the first argument
  args = ARGV.dup
  args.shift if args.first == "cask"

  puts "Installing cask(s): #{args.join(", ")}"
  success = system "brew", "install", "--cask", *args
else
  # For formula installs
  puts "Installing formula(e): #{ARGV.join(", ")}"
  success = system "brew", "install", *ARGV
end

# Check result
unless success
  abort "Installation failed! Check the output above for errors."
end

#!/usr/bin/env brew ruby
# frozen_string_literal: true

# dump_formulae: given a Homebrew installation, dumps a JSON
# representation of all available packages.

require "optparse"
require "json"
require "securerandom"
require_relative "../lib/homebrew_paths"
require_relative "../lib/safe_shell"
require_relative "../lib/cask_helpers"
require_relative "../lib/container_helpers"
require_relative "../lib/download_helpers"
require_relative "../lib/url_helpers"
require_relative "../lib/tap_manager"
require_relative "../lib/dependency_resolver"

# We need Homebrew's libraries.
abort "Make sure to run me via `brew ruby`!" unless Object.const_defined? :Homebrew

# Define Homebrew CLI output methods if not available
# These are normally provided by Homebrew's command infrastructure
unless defined?(ohai)
  def ohai(message)
    puts message
  end

  def opoo(message)
    warn message
  end

  def onoe(message)
    warn "Error: #{message}"
  end

  def odebug(message)
    puts "Debug: #{message}" if ENV["HOMEBREW_DEBUG"]
  end

  def odie(message)
    abort "Error: #{message}"
  end
end

# Load Cask API if available
begin
  require "cask/cask_loader"
  require "cask/cask"
rescue LoadError
  # Cask API not available - cask mirroring will be skipped
end

# Represents a mirrorable resource.
# A `fetchable` is anything that responds to `#fetch`.
# An `identifier` is a unique string that will ultimately identify the resource on the mirror.
# A `downloader` is also something that responds to `#fetch` and `#cached_location`
# A `url` is the resource's actual asset.
MirrorResource = Struct.new(:fetchable, :identifier, :downloader, :url)

# Supported download strategies for offline mirroring
# These strategies cover >99% of Homebrew formulae.
# The list is built defensively to handle different Homebrew versions.
BREW_OFFLINE_DOWNLOAD_STRATEGIES = [
  # HTTP/HTTPS download strategies (most common)
  CurlDownloadStrategy,
  CurlApacheMirrorDownloadStrategy,
  NoUnzipCurlDownloadStrategy,

  # Git-based strategies (deterministic identifiers via Task 3.2)
  GitDownloadStrategy,
  GitHubGitDownloadStrategy,

  # Additional strategies that may exist in newer Homebrew versions
  # Using defined?() to safely check if they exist
  (defined?(CurlBottleDownloadStrategy) ? CurlBottleDownloadStrategy : nil),
  (defined?(LocalBottleDownloadStrategy) ? LocalBottleDownloadStrategy : nil),
].compact.freeze

# Unsupported strategies (require external tools):
# - SubversionDownloadStrategy (requires svn binary)
# - MercurialDownloadStrategy (requires hg binary)
# - CVSDownloadStrategy (requires cvs binary)
# - BazaarDownloadStrategy (requires bzr binary)
# - FossilDownloadStrategy (requires fossil binary)
# See mirror/docs/DOWNLOAD_STRATEGIES.md for details

# Resolve the actual Git commit for a repository.
# This ensures we get the real commit hash, not just "master" or "HEAD".
def resolve_git_revision(downloader)
  return "HEAD" unless downloader.is_a?(GitDownloadStrategy) ||
                       downloader.is_a?(GitHubGitDownloadStrategy)

  # Try to get the resolved reference (actual commit hash)
  if downloader.respond_to?(:resolved_ref) && downloader.resolved_ref
    return downloader.resolved_ref
  end

  # Try to get the ref (branch name, tag, or commit)
  if downloader.respond_to?(:ref) && downloader.ref
    return downloader.ref
  end

  # Default to HEAD if we can't determine the revision
  "HEAD"
end

# Given a download strategy, produce a sensible and deterministic identifier.
def sensible_identifier(strategy, checksum = nil, url = nil)
  case strategy
  when GitDownloadStrategy, GitHubGitDownloadStrategy
    # Git/GitHub resources don't have checksums, so we create a deterministic
    # identifier based on the URL and revision. This prevents duplicate mirrors
    # of the same repository at the same commit.
    require "digest"

    # Get the revision/commit being checked out
    revision = resolve_git_revision(strategy)

    # Create deterministic hash: SHA256(url + revision)
    # This ensures the same repo at the same commit always gets the same identifier
    Digest::SHA256.hexdigest("#{url}@#{revision}")
  else
    checksum.to_s
  end
end

# Given a download strategy and an (extant) download location,
# do any necessary preparation.
# For now, this just preps `git` repos so that they can be accessed
# via a dumb HTTP mirror.
def prep_location!(strategy, location)
  case strategy
  when GitDownloadStrategy, GitHubGitDownloadStrategy
    Dir.chdir location do
      ohai "\t\tRepo prep: #{location}"
      if `git rev-parse --is-shallow-repository`.chomp == "true"
        ohai "\t\tFound what looks like a shallow repo, unshallowing it..."
        `git fetch --quiet --unshallow`
      end
      `git update-server-info`
    end
  end
end

options = {
  directory: "/Users/william/tmp/brew-mirror",
  baseurl: "http://localhost:8000",
  sleep: 0.5,
  config_only: false,
  iterator: Formula,
  casks: nil,
  taps: ["homebrew/homebrew-core", "homebrew/homebrew-cask"],  # Default taps
  verify: false,
  update_mode: false,
  prune_old: false,
  with_deps: false,          # Automatic dependency resolution (Phase 6)
  include_build: false,      # Include build dependencies (Phase 6)
}

OptionParser.new do |parser|
  parser.banner = "Usage: brew ruby brew-mirror [options]"

  parser.on "-d", "--directory DIRECTORY" do |d|
    options[:directory] = d
  end

  parser.on "-s", "--sleep SECS", Float, "sleep between each formula download" do |s|
    options[:sleep] = s
  end

  parser.on "-c", "--config-only", "write configuration files but don't perform the mirror" do
    options[:config_only] = true
  end

  parser.on "-f", "--formulae f1,f2,f2", Array, "mirror just the given formulae" do |formulae|
    options[:iterator] = formulae.map { |f| Formula[f] }
  end

  parser.on "--casks c1,c2,c3", Array, "mirror just the given casks" do |casks|
    options[:casks] = casks
  end

  parser.on "--taps tap1,tap2", Array, "specify taps to mirror (default: core,cask)" do |taps|
    options[:taps] = taps
  end

  parser.on "--verify", "verify mirror integrity after creation" do
    options[:verify] = true
  end

  parser.on "--update", "update existing mirror (skip unchanged packages)" do
    options[:update_mode] = true
  end

  parser.on "--prune", "remove old versions when updating" do
    options[:prune_old] = true
  end

  parser.on "--with-deps", "automatically include all dependencies" do
    options[:with_deps] = true
  end

  parser.on "--include-build", "include build dependencies (requires --with-deps)" do
    options[:include_build] = true
  end
end.parse!

# Validate options
if options[:include_build] && !options[:with_deps]
  abort "Error: --include-build requires --with-deps\n" \
        "Usage: brew offline mirror -f wget --with-deps --include-build"
end

abort "Fatal: the output directory must exist" unless Dir.exist?(options[:directory])

# Dump the configured taps' commits, the timestamp,
# and the path of our cache to the directory that brew-offline reads.
ohai "Writing brew-offline config..."

config = {}
config[:taps] = {}

# Process each configured tap
options[:taps].each do |tap_name|
  # Expand shorthand tap names (e.g., "core" -> "homebrew/homebrew-core")
  expanded_tap_name = TapManager.expand_tap_name(tap_name)

  unless TapManager.tap_installed?(expanded_tap_name)
    opoo "Tap not installed: #{expanded_tap_name}"
    # Only show expected location for non-bundled taps
    unless ["homebrew/homebrew-core", "homebrew/homebrew-cask"].include?(expanded_tap_name)
      tap_dir = TapManager.tap_directory(expanded_tap_name)
      opoo "  Expected location: #{tap_dir}"
    end
    next
  end

  commit = TapManager.tap_commit(expanded_tap_name)
  unless commit
    opoo "Could not get commit for #{expanded_tap_name}, skipping"
    next
  end

  tap_type = TapManager.tap_type(expanded_tap_name)

  config[:taps][expanded_tap_name] = {
    "commit" => commit,
    "type" => tap_type,
  }

  ohai "Will mirror #{expanded_tap_name} (#{tap_type}) at commit #{commit[0..7]}"
end

# Ensure at least one tap configured
if config[:taps].empty?
  # List installed taps to help user
  installed_taps = TapManager.all_installed_taps

  puts "\nFatal: No valid taps configured!"
  puts "\nYou requested: #{options[:taps].map { |t| TapManager.expand_tap_name(t) }.join(', ')}"

  if installed_taps.empty?
    puts "\nNo taps are currently installed on your system."
    puts "Install taps with: brew tap <tap-name>"
    puts "Example: brew tap homebrew/core"
  else
    puts "\nInstalled taps on your system:"
    installed_taps.each { |tap| puts "  - #{tap}" }
    puts "\nTo mirror these taps, use: --taps #{installed_taps.join(',')}"
  end

  abort
end

# Add metadata to config
config[:stamp] = Time.now.to_i
config[:baseurl] = options[:baseurl] if options[:baseurl]

File.write File.join(options[:directory], "config.json"), config.to_json

# Initialize urlmap (will be empty in config-only mode)
urlmap = {}

# Load existing identifier cache if it exists
# This prevents duplicate mirroring of the same Git repository at the same commit
identifier_cache_file = File.join(options[:directory], "identifier_cache.json")
identifier_cache = if File.exist?(identifier_cache_file)
                     JSON.parse(File.read(identifier_cache_file))
                   else
                     {}
                   end

# Initialize or load manifest for documenting the mirror contents
existing_manifest = nil
if options[:update_mode]
  manifest_file = File.join(options[:directory], "manifest.json")
  if File.exist?(manifest_file)
    existing_manifest = JSON.parse(File.read(manifest_file), symbolize_names: true)
    ohai "Loading existing manifest for incremental update"
    ohai "  Previous mirror created: #{existing_manifest[:created_at]}"
    ohai "  Previous formulae: #{existing_manifest[:formulae].count}"
    ohai "  Previous casks: #{existing_manifest[:casks].count}"
  else
    opoo "No existing manifest found, performing full mirror"
    options[:update_mode] = false  # Fallback to full mirror
  end
end

manifest = {
  created_at: Time.now.iso8601,
  taps: {},
  statistics: {
    total_formulae: 0,
    total_casks: 0,
    total_files: 0,
    total_size_bytes: 0,
  },
  formulae: existing_manifest ? existing_manifest[:formulae].dup : [],
  casks: existing_manifest ? existing_manifest[:casks].dup : [],
  dependency_resolution: nil,  # Will be populated if --with-deps is used
}

# In config-only mode, write empty urlmap and exit early
if options[:config_only]
  File.write File.join(options[:directory], "urlmap.json"), urlmap.to_json
  exit
end

# Helper function to normalize tap names
# Homebrew API returns "homebrew/core" but we store "homebrew/homebrew-core"
# Also handles case sensitivity (Homebrew/core vs homebrew/core)
def normalize_tap_name(tap_name)
  # First, convert to lowercase for case-insensitive matching
  tap_name = tap_name.downcase

  # Convert short form to full form
  # "homebrew/core" -> "homebrew/homebrew-core"
  # "homebrew/cask" -> "homebrew/homebrew-cask"
  if tap_name =~ %r{^([^/]+)/([^/]+)$}
    user = $1
    repo = $2
    # If repo doesn't start with "homebrew-", add it
    if user == "homebrew" && !repo.start_with?("homebrew-")
      "#{user}/homebrew-#{repo}"
    else
      tap_name
    end
  else
    tap_name
  end
end

# Generate HTML report from manifest
def generate_html_report(manifest, output_file)
  html = <<~HTML
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <title>Offlinebrew Mirror Manifest</title>
      <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; border-bottom: 3px solid #f90; padding-bottom: 10px; }
        h2 { color: #555; margin-top: 30px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px 8px; text-align: left; }
        th { background: #f2f2f2; font-weight: 600; }
        tr:hover { background: #f9f9f9; }
        .stats { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; margin: 20px 0; border-radius: 8px; }
        .stats h2 { color: white; margin-top: 0; }
        .stats p { margin: 8px 0; font-size: 16px; }
        .stats strong { font-weight: 600; }
        code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-family: "Monaco", "Courier New", monospace; }
      </style>
    </head>
    <body>
      <div class="container">
        <h1>üç∫ Offlinebrew Mirror Manifest</h1>

        <div class="stats">
          <h2>üìä Statistics</h2>
          <p><strong>Created:</strong> #{manifest[:created_at]}</p>
          <p><strong>Formulae:</strong> #{manifest[:statistics][:total_formulae]}</p>
          <p><strong>Casks:</strong> #{manifest[:statistics][:total_casks]}</p>
          <p><strong>Total Files:</strong> #{manifest[:statistics][:total_files]}</p>
          <p><strong>Total Size:</strong> #{(manifest[:statistics][:total_size_bytes] / 1024.0 / 1024.0 / 1024.0).round(2)} GB</p>
        </div>

        <h2>üì¶ Taps</h2>
        <table>
          <tr><th>Tap</th><th>Commit</th><th>Type</th></tr>
  HTML

  manifest[:taps].each do |tap, info|
    # Show full commit for bundled taps, truncate git commits to 8 chars
    commit_display = info["commit"].start_with?("bundled-") ? info["commit"] : info["commit"][0..7]
    html += "        <tr><td><code>#{tap}</code></td><td><code>#{commit_display}</code></td><td>#{info["type"]}</td></tr>\n"
  end

  html += <<~HTML
        </table>

        <h2>‚öóÔ∏è  Formulae (#{manifest[:formulae].count})</h2>
        <table>
          <tr><th>Name</th><th>Version</th><th>Tap</th></tr>
  HTML

  manifest[:formulae].each do |formula|
    html += "        <tr><td><code>#{formula[:name]}</code></td><td>#{formula[:version]}</td><td><code>#{formula[:tap]}</code></td></tr>\n"
  end

  html += <<~HTML
        </table>

        <h2>üì¶ Casks (#{manifest[:casks].count})</h2>
        <table>
          <tr><th>Token</th><th>Name</th><th>Version</th></tr>
  HTML

  manifest[:casks].each do |cask|
    html += "        <tr><td><code>#{cask[:token]}</code></td><td>#{cask[:name]}</td><td>#{cask[:version]}</td></tr>\n"
  end

  html += <<~HTML
        </table>
      </div>
    </body>
    </html>
  HTML

  File.write(output_file, html)
end

# Resolve dependencies if requested (Phase 6: Task 6.1.3)
cask_formula_deps = []

# First, resolve cask dependencies if casks were specified
# We do this first so we can include formula dependencies in the formula loop
if options[:with_deps] && options[:casks]
  ohai "Resolving cask dependencies first..."
  original_cask_tokens = options[:casks].dup  # Save original request

  resolved = DependencyResolver.resolve_casks(
    options[:casks],
    include_build: options[:include_build]
  )

  # Update casks list
  options[:casks] = resolved[:casks]

  # Save formula dependencies to add to formula iterator
  cask_formula_deps = resolved[:formulas]

  if cask_formula_deps.any?
    ohai "Found #{cask_formula_deps.count} formula dependencies for casks"
  end

  # Record cask dependency resolution in manifest
  if original_cask_tokens.any?
    manifest[:dependency_resolution] = {
      enabled: true,
      include_build: options[:include_build],
      requested_casks: original_cask_tokens,
      resolved_casks: resolved[:casks],
      cask_formula_deps: cask_formula_deps,
    }
  end
end

# Now resolve formula dependencies
if options[:with_deps] && options[:iterator] != Formula
  # User specified specific formulas with -f and wants dependencies
  formula_names = options[:iterator].map(&:name)
  original_formula_names = formula_names.dup  # Save original request

  # Add cask formula dependencies
  formula_names += cask_formula_deps
  formula_names.uniq!

  ohai "Dependency resolution enabled (--with-deps)"
  resolved_names = DependencyResolver.resolve_formulas(
    formula_names,
    include_build: options[:include_build],
    include_optional: false
  )

  # Update iterator with resolved formulas
  # Use filter_map to handle formulas that may have become unavailable
  options[:iterator] = resolved_names.filter_map do |name|
    begin
      Formula[name]
    rescue FormulaUnavailableError
      opoo "Formula #{name} no longer available, skipping"
      nil
    end
  end

  original_count = formula_names.count - cask_formula_deps.count
  added_count = resolved_names.count - original_count
  if added_count > 0
    ohai "Added #{added_count} formula dependencies to mirror list"
  end

  # Record dependency resolution in manifest (merge with any cask data)
  manifest[:dependency_resolution] ||= {}
  manifest[:dependency_resolution].merge!({
    enabled: true,
    include_build: options[:include_build],
    requested_formulas: original_formula_names - cask_formula_deps,
    resolved_formulas: resolved_names,
    auto_added_count: added_count,
  })
  # Add cask_formula_deps if not already present
  manifest[:dependency_resolution][:cask_formula_deps] ||= cask_formula_deps
elsif options[:with_deps] && options[:iterator] == Formula && cask_formula_deps.any?
  # Mirroring all formulas - but we have cask formula deps
  # They'll be included anyway since we're mirroring everything
  ohai "Mirroring all formulas (cask dependencies will be included)"
elsif options[:with_deps] && options[:iterator] == Formula
  # Mirroring all formulas - dependency resolution not needed
  ohai "Mirroring all formulas - dependency resolution not needed"
end

# Finally, fetch the (stable) resources for each formula from configured taps.
# Skip formula mirroring if only casks were requested (no -f flag, but --casks flag)
skip_formulas = options[:iterator] == Formula && options[:casks]

unless skip_formulas
  formula_iterator = options[:iterator] == Formula ? Formula.all : options[:iterator]

  formula_iterator.each do |formula|
  # Skip formulae that aren't in configured taps
  # Handle different tap types (CoreTap, Tap, etc.)
  formula_tap_name = if formula.tap.respond_to?(:full_name)
                       formula.tap.full_name
                     elsif formula.tap.core_tap?
                       "homebrew/core"  # Use short form, will be normalized
                     elsif formula.tap.respond_to?(:user) && formula.tap.respond_to?(:repo)
                       "#{formula.tap.user}/#{formula.tap.repo}"
                     else
                       # Fallback: try to get name from tap
                       formula.tap.to_s
                     end

  # Debug: Show tap name before and after normalization
  original_tap_name = formula_tap_name
  formula_tap_name = normalize_tap_name(formula_tap_name)

  if ENV["HOMEBREW_VERBOSE"]
    puts "DEBUG: Formula #{formula.name}"
    puts "  Original tap: #{original_tap_name}"
    puts "  Normalized tap: #{formula_tap_name}"
    puts "  Config taps: #{config[:taps].keys.inspect}"
    puts "  Match: #{config[:taps].key?(formula_tap_name)}"
  end

  next unless config[:taps].key?(formula_tap_name)

  # In update mode, skip formulae that haven't changed
  if existing_manifest && options[:update_mode]
    already_mirrored = existing_manifest[:formulae].any? do |f|
      f[:name] == formula.name && f[:version] == formula.version.to_s
    end

    if already_mirrored
      ohai "#{formula.name} (#{formula.version}) already in mirror, skipping"
      # Keep it in the new manifest
      unless manifest[:formulae].any? { |f| f[:name] == formula.name }
        manifest[:formulae] << {
          name: formula.name,
          version: formula.version.to_s,
          url: formula.stable.url,
          tap: formula_tap_name,
        }
        manifest[:statistics][:total_formulae] += 1
      end
      next
    else
      ohai "#{formula.name} (#{formula.version}) is new or updated, downloading"
    end
  end

  ohai "Collecting resources for #{formula.name}..."

  # Build up a list of MirrorResources for the formula.
  # Every formula has three primary sources of resources:
  #   1. The top-level SoftwareSpec, in our case always the "stable" spec
  #   2. The resources (assets, in-tree dependencies) defined under the "stable" spec
  #   3. The patches for the "stable" spec
  resources = []

  resources << MirrorResource.new(formula.stable,
                                  sensible_identifier(formula.stable.downloader,
                                                      formula.stable.checksum,
                                                      formula.stable.url),
                                  formula.stable.downloader,
                                  formula.stable.url)

  formula.stable.resources.each do |_name, res|
    resources << MirrorResource.new(res,
                                    sensible_identifier(res.downloader,
                                                        res.checksum,
                                                        res.url),
                                    res.downloader,
                                    res.url)
  end

  formula.stable.patches.select(&:external?).each do |patch|
    resources << MirrorResource.new(patch,
                                    sensible_identifier(patch.resource.downloader,
                                                        patch.resource.checksum,
                                                        patch.url),
                                    patch.resource.downloader,
                                    patch.url)
  end

  # Make sure every resource in the formula is retrievable via one of the
  # download strategies supported by our mirror, skipping (and logging) the formula
  # if one or more isn't.
  bad_resources = resources.reject do |res|
    BREW_OFFLINE_DOWNLOAD_STRATEGIES.include? res.downloader.class
  end

  # TODO(ww): Maybe just log unmirrorable resources, and allow users to attempt to
  # mirror them manually. I'm not sure yet what that will entail for SVN.
  if bad_resources.any?
    bad_resources.each do |res|
      opoo "#{formula.name} has an unmirrorable resource: #{res.url} (#{res.downloader.class})"
    end
    next
  end

  ohai "Downloading resources for #{formula.name}..."

  resources.each do |res|
    # We'll do the logging here.
    # Suppress downloader output (quiet! in newer Homebrew, shutup! in older versions)
    if res.downloader.respond_to?(:quiet!)
      res.downloader.quiet!
    elsif res.downloader.respond_to?(:shutup!)
      res.downloader.shutup!
    end
    ohai "\tResource url: #{res.url}"

    old_location = res.downloader.cached_location
    new_location = Pathname.new(File.join(options[:directory],
                                          "#{res.identifier}#{old_location.extname}"))

    res.downloader.fetch unless new_location.exist?

    if new_location.exist?
      ohai "\tAlready migrated!"
    else
      FileUtils.mv old_location.to_s, new_location.to_s, force: true
      prep_location! res.downloader, new_location.to_s
      ohai "\t#{old_location} -> #{new_location}"
    end

    # Track Git repositories in identifier cache for idempotent mirroring
    if res.downloader.is_a?(GitDownloadStrategy) || res.downloader.is_a?(GitHubGitDownloadStrategy)
      revision = resolve_git_revision(res.downloader)
      cache_key = "#{res.url}@#{revision}"
      identifier_cache[cache_key] = {
        "identifier" => res.identifier,
        "url" => res.url.to_s,
        "revision" => revision,
        "filename" => new_location.basename.to_s,
      }
    end

    # Add to the urlmap (with URL variants for better matching)
    url_str = res.url.to_s
    urlmap[url_str] = new_location.basename

    # Also add clean URL variant (without query/fragment) for easier matching
    clean_url = URLHelpers.clean_url(url_str)
    urlmap[clean_url] = new_location.basename unless clean_url == url_str
  end

  # Track formula in manifest
  manifest[:formulae] << {
    name: formula.name,
    version: formula.version.to_s,
    url: formula.stable.url,
    tap: formula_tap_name,
  }
  manifest[:statistics][:total_formulae] += 1

  sleep options[:sleep]
  end
end # unless skip_formulas

# Mirror casks from all configured cask taps
# Skip cask mirroring if specific formulae were requested but no casks were
skip_casks = options[:iterator] != Formula && options[:casks].nil?

cask_taps = config[:taps].select { |tap_name, tap_info|
  tap_type = tap_info["type"] || tap_info[:type]
  tap_type == "cask" || tap_type == "mixed"
}

if skip_casks
  ohai "Skipping cask mirroring (use --casks to mirror specific casks)"
elsif CaskHelpers.cask_api_available? && !cask_taps.empty?
  cask_taps.each do |tap_name, tap_info|
    ohai "Mirroring casks from #{tap_name}..."

    # Determine which casks to mirror
    cask_iterator = if options[:casks]
                      # Specific casks requested via CLI
                      CaskHelpers.load_casks(options[:casks])
                    else
                      # All casks from this tap
                      # For now, CaskHelpers.all_casks returns all installed casks
                      # We'll filter by tap name below
                      CaskHelpers.all_casks
                    end

  cask_iterator.each do |cask|
    # Skip casks that aren't from this tap
    # Only filter by tap if we're not mirroring specific casks via --casks
    if !options[:casks] && cask.respond_to?(:tap) && cask.tap
      # Handle different tap types (CoreTap, Tap, etc.)
      cask_tap_name = if cask.tap.respond_to?(:full_name)
                        cask.tap.full_name
                      elsif cask.tap.respond_to?(:user) && cask.tap.respond_to?(:repo)
                        "#{cask.tap.user}/#{cask.tap.repo}"
                      else
                        # Fallback: try to get name from tap
                        cask.tap.to_s
                      end

      # Normalize both tap names for comparison
      cask_tap_name = normalize_tap_name(cask_tap_name)
      normalized_tap_name = normalize_tap_name(tap_name)
      next unless cask_tap_name == normalized_tap_name
    end

    # In update mode, skip casks that haven't changed
    if existing_manifest && options[:update_mode]
      already_mirrored = existing_manifest[:casks].any? do |c|
        c[:token] == cask.token && c[:version] == cask.version.to_s
      end

      if already_mirrored
        ohai "#{cask.token} (#{cask.version}) already in mirror, skipping"
        # Keep it in the new manifest
        unless manifest[:casks].any? { |c| c[:token] == cask.token }
          manifest[:casks] << {
            token: cask.token,
            name: (cask.name.first rescue cask.token),
            version: cask.version.to_s,
            url: cask.url.to_s,
          }
          manifest[:statistics][:total_casks] += 1
        end
        next
      else
        ohai "#{cask.token} (#{cask.version}) is new or updated, downloading"
      end
    end

    ohai "Collecting resources for cask: #{cask.token}..."

    # Casks have a simpler structure than formulae
    # They typically have one URL that points to the application bundle
    begin
      # Skip casks without URLs
      unless CaskHelpers.has_url?(cask)
        opoo "#{cask.token} has no downloadable URL, skipping"
        next
      end

      url = cask.url
      url_str = url.to_s
      ohai "\tCask URL: #{url_str}"

      # Determine download strategy
      # Casks typically use CurlDownloadStrategy
      # Modern Homebrew's Cask::URL doesn't have a .downloader method,
      # so we need to instantiate the strategy ourselves
      begin
        # Try to get download strategy from URL metadata if available
        if url.respond_to?(:download_strategy)
          strategy_class = url.download_strategy
        else
          # Default to CurlDownloadStrategy for casks (most common)
          strategy_class = CurlDownloadStrategy
        end

        unless BREW_OFFLINE_DOWNLOAD_STRATEGIES.include?(strategy_class)
          opoo "#{cask.token} uses unsupported download strategy: #{strategy_class}"
          next
        end

        # Instantiate the downloader with cask metadata
        # Try different constructor signatures for compatibility
        downloader = begin
          # Modern Homebrew: url, name, version
          strategy_class.new(url_str, cask.token, cask.version)
        rescue ArgumentError
          # Fallback: url, name
          strategy_class.new(url_str, cask.token)
        rescue ArgumentError
          # Fallback: url only
          strategy_class.new(url_str)
        end
      rescue => e
        opoo "Failed to create downloader for #{cask.token}: #{e.message}"
        next
      end

      # Create a sensible identifier (casks usually have checksums)
      checksum = CaskHelpers.checksum(cask)
      identifier = if checksum && checksum != :no_check
                     checksum.to_s
                   else
                     # No checksum, use URL-based hash
                     require "digest"
                     Digest::SHA256.hexdigest(url_str)
                   end

      # Detect container extension (DMG, PKG, ZIP, etc.)
      extension = ContainerHelpers.detect_extension(url_str)
      new_location = Pathname.new(File.join(options[:directory],
                                            "#{identifier}#{extension}"))

      # Check if already downloaded to mirror
      if new_location.exist?
        ohai "\tAlready mirrored: #{ContainerHelpers.human_size(new_location)}"
        ohai "\t  Type: #{ContainerHelpers.container_type(new_location)}"

        # Add to urlmap (with URL variants for better matching)
        urlmap[url_str] = new_location.basename.to_s

        # Also add clean URL variant (without query/fragment) for easier matching
        clean_url = URLHelpers.clean_url(url_str)
        urlmap[clean_url] = new_location.basename.to_s unless clean_url == url_str

        next  # Skip to next cask
      end

      # Download with retry logic
      # Suppress downloader output (quiet! in newer Homebrew, shutup! in older versions)
      if downloader.respond_to?(:quiet!)
        downloader.quiet!
      elsif downloader.respond_to?(:shutup!)
        downloader.shutup!
      end

      # Check if already in Homebrew cache
      if DownloadHelpers.cached?(downloader)
        cached_size = DownloadHelpers.cached_size(downloader)
        ohai "\tFound in Homebrew cache: #{ContainerHelpers.human_size(Pathname.new(cached_size.to_s))}" if cached_size
      else
        ohai "\tDownloading..."
        start_time = Time.now

        unless DownloadHelpers.fetch_with_retry(downloader, max_retries: 2)
          opoo "Download failed for #{url_str} after retries"
          next
        end

        elapsed = Time.now - start_time
        ohai "\tDownload completed in #{elapsed.round(1)}s"
      end

      # Move from cache to mirror location
      old_location = downloader.cached_location
      unless old_location.exist?
        opoo "Downloaded file not found at #{old_location}"
        next
      end

      FileUtils.mv old_location.to_s, new_location.to_s, force: true

      # Verify the container
      if ContainerHelpers.verify_container(new_location)
        ohai "\t‚úì Verified: #{ContainerHelpers.human_size(new_location)}"
        ohai "\t  Type: #{ContainerHelpers.container_type(new_location)}"
      else
        opoo "\t‚ö† Verification failed (file may be corrupted)"
        ohai "\t  Size: #{ContainerHelpers.human_size(new_location)}"
      end

      # Verify checksum if available
      if checksum && checksum != :no_check
        if DownloadHelpers.verify_checksum(new_location, checksum)
          ohai "\t‚úì Checksum verified"
        else
          opoo "\t‚ö† Checksum mismatch!"
        end
      end

      # Add to urlmap (with URL variants for better matching)
      urlmap[url_str] = new_location.basename.to_s

      # Also add clean URL variant (without query/fragment) for easier matching
      clean_url = URLHelpers.clean_url(url_str)
      urlmap[clean_url] = new_location.basename.to_s unless clean_url == url_str

      # Track cask in manifest
      manifest[:casks] << {
        token: cask.token,
        name: (cask.name.first rescue cask.token),
        version: cask.version.to_s,
        url: url_str,
      }
      manifest[:statistics][:total_casks] += 1

    rescue StandardError => e
      opoo "Failed to mirror cask #{cask.token}: #{e.message}"
      puts "  #{e.backtrace.first(3).join("\n  ")}" if ENV["HOMEBREW_VERBOSE"]
      next
    end

    sleep options[:sleep]
  end
  end  # end of cask_taps.each

  # Print overall cask mirror statistics
  ohai "Cask mirror statistics:"

  # Count files by extension
  cask_files = Dir.glob("#{options[:directory]}/*.{dmg,pkg,zip,tar.gz}").select { |f| File.file?(f) }
  puts "  Container files: #{cask_files.count}"

  # Calculate total size
  if cask_files.any?
    total_bytes = cask_files.sum { |f| File.size(f) }
    require_relative "../lib/container_helpers"
    total_size = ContainerHelpers.format_bytes(total_bytes)
    puts "  Total cask size: #{total_size}"
  end

  puts ""
else
  if !CaskHelpers.cask_api_available?
    ohai "Skipping cask mirroring (Cask API not available)"
  elsif !HomebrewPaths.cask_tap_exists?
    ohai "Skipping cask mirroring (homebrew-cask tap not found)"
  end
end

# Write urlmap.json
File.write File.join(options[:directory], "urlmap.json"), urlmap.to_json

# Calculate final manifest statistics
manifest[:statistics][:total_files] = urlmap.count
manifest[:statistics][:total_size_bytes] = Dir.glob("#{options[:directory]}/*")
  .select { |f| File.file?(f) }
  .map { |f| File.size(f) rescue 0 }
  .sum

# Add tap info to manifest
config[:taps].each do |tap_name, tap_info|
  manifest[:taps][tap_name] = tap_info
end

# Prune old versions if requested
if options[:prune_old] && existing_manifest
  ohai "Pruning old versions from mirror..."

  # Find formulae that were removed or updated
  old_formulae = existing_manifest[:formulae] || []
  new_formulae = manifest[:formulae] || []

  old_formulae.each do |old_f|
    # Check if this formula is gone or has a different version
    current = new_formulae.find { |f| f[:name] == old_f[:name] }

    if current.nil?
      ohai "  Removed formula: #{old_f[:name]} (#{old_f[:version]})"
      # Note: Files are referenced by checksum, not formula name
      # So we can't easily remove them without tracking formula->file mapping
      # For now, just log it
    elsif current[:version] != old_f[:version]
      ohai "  Updated formula: #{old_f[:name]} (#{old_f[:version]} -> #{current[:version]})"
      # Old version files will remain unless we track them
    end
  end

  # Find casks that were removed or updated
  old_casks = existing_manifest[:casks] || []
  new_casks = manifest[:casks] || []

  old_casks.each do |old_c|
    # Check if this cask is gone or has a different version
    current = new_casks.find { |c| c[:token] == old_c[:token] }

    if current.nil?
      ohai "  Removed cask: #{old_c[:token]} (#{old_c[:version]})"
    elsif current[:version] != old_c[:version]
      ohai "  Updated cask: #{old_c[:token]} (#{old_c[:version]} -> #{current[:version]})"
    end
  end

  puts ""
  puts "Note: --prune currently only reports changes. Actual file removal requires"
  puts "tracking formula/cask names to their downloaded files. This will be added"
  puts "in a future update. For now, you can manually remove old files from the mirror."
  puts ""
end

# Write manifest.json
manifest_file = File.join(options[:directory], "manifest.json")
File.write manifest_file, JSON.pretty_generate(manifest)
ohai "Manifest written to: manifest.json"

# Generate API JSON files for formulas
require_relative "../lib/api_generator"
api_dir = File.join(options[:directory], "api")
if options[:iterator] && options[:iterator] != Formula
  # User specified specific formulas - get them from iterator
  formula_objects = options[:iterator]
elsif manifest[:formulae].any?
  # Get all formulas from manifest
  formula_objects = manifest[:formulae].map { |f| Formula[f[:name]] rescue nil }.compact
else
  formula_objects = []
end

if formula_objects.any?
  ApiGenerator.generate_all(formula_objects, api_dir)
  ohai "Generated API JSON for #{formula_objects.count} formulas"
else
  ohai "No formulas to generate API JSON for"
end

# Generate HTML report
html_file = File.join(options[:directory], "manifest.html")
generate_html_report(manifest, html_file)
ohai "HTML report written to: manifest.html"

# Write identifier cache for Git repository tracking
# This tracks all Git identifiers to prevent duplicates on subsequent mirror runs
File.write identifier_cache_file, JSON.pretty_generate(identifier_cache)

# Verify mirror if requested
if options[:verify]
  ohai "Verifying mirror integrity..."
  puts ""

  # Load and execute the verify script directly
  # This works because we're already in brew ruby context
  verify_script = File.expand_path("brew-mirror-verify", __dir__)

  # Set ARGV for the verify script and load it
  old_argv = ARGV.dup
  ARGV.clear
  ARGV << options[:directory]

  begin
    load verify_script
  rescue SystemExit => e
    # Verify script calls exit, propagate the exit code
    exit e.status
  ensure
    # Restore original ARGV (though we'll exit anyway)
    ARGV.clear
    ARGV.concat(old_argv)
  end
end

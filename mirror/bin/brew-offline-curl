#!/usr/bin/env ruby
# frozen_string_literal: true

# brew-offline-curl: Shims HOMEBREW_CURL to provide transparent URL redirection.
#
# This script intercepts curl calls from Homebrew and redirects URLs to a local mirror.
# It handles various URL patterns including query parameters and fragments.

STDERR.puts "DEBUG: brew-offline-curl INVOKED with args: #{ARGV.inspect}"

require "uri"
require "json"
require_relative "../lib/offlinebrew_config"
require_relative "../lib/url_helpers"

def verbose(msg)
  STDERR.puts "[+] #{msg}" if ENV["HOMEBREW_VERBOSE"]
end

def debug(msg)
  if ENV["HOMEBREW_VERBOSE"] || ENV["BREW_OFFLINE_DEBUG"]
    STDERR.puts "[brew-offline-curl] #{msg}"
  end
end

# Use OfflinebrewConfig to find config files, even when running in a sandbox
BREW_OFFLINE_CONFIG = OfflinebrewConfig.config_path
BREW_OFFLINE_URLMAP = OfflinebrewConfig.urlmap_path

begin
  config = JSON.parse File.read(BREW_OFFLINE_CONFIG), symbolize_names: true
  urlmap = JSON.parse File.read(BREW_OFFLINE_URLMAP)
rescue RuntimeError => e
  STDERR.puts "Fatal: Couldn't read config or urlmap?"
  raise e
end

# Check if this is a HEAD request
is_head_request = ARGV.include?("-I") || ARGV.include?("--head")
debug "HEAD request detected" if is_head_request

# I don't think Homebrew currently batches `curl` calls together, so
# we should never see more than 1 URL at a time anyways.
# However, it doesn't hurt to be generic.
urls = ARGV.select { |arg| URI.regexp(%w[http https]) =~ arg }

# Map each URL to its mirror equivalent
mirror_urls = urls.map do |url|
  debug "Looking up URL: #{url}"

  # Try to find the URL in the urlmap (handles variants)
  mapped_file = URLHelpers.find_in_urlmap(url, urlmap)

  if mapped_file
    mirror_url = URI.join(config[:baseurl], mapped_file)
    debug "✓ Found mapping: #{url} -> #{mapped_file}"
    mirror_url
  else
    # No mapping found - warn and return original URL
    # This will fail if truly offline, but allows debugging
    variants = URLHelpers.normalize_for_matching(url)
    debug "✗ No mapping found for: #{url}"
    debug "  Tried variants: #{variants.first(3).join(", ")}#{variants.length > 3 ? "..." : ""}"
    verbose "WARNING: No mirror URL found for #{url}"
    verbose "This download will fail if offline"
    url  # Return original URL
  end
end

# Replace URLs in ARGV with mirror URLs
urls.zip(mirror_urls).each do |original_url, mirror_url|
  verbose "#{original_url} -> #{mirror_url}"
  ARGV[ARGV.index(original_url)] = mirror_url.to_s
end

exec "curl", *ARGV
